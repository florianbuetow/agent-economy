# Service Implementation Guide

This guide describes every file needed to turn a scaffolded service into a running service. It is intended to be read by an agent (human or AI) who is about to implement a service and needs to know exactly which files to create, where to place them, and what patterns to follow.

The scaffolding has already created the directory structure, `pyproject.toml`, `justfile`, `Dockerfile`, `config.yaml`, and `pyrightconfig.json`. What remains is the Python source code and tests.

---

## Directory Structure — Complete Service

Below is the full file listing for a completed service. Files marked with `[scaffolded]` already exist. Files marked with `[create]` need to be written during implementation.

```
services/{service-dir}/
├── justfile                                          [scaffolded]
├── pyproject.toml                                    [scaffolded]
├── pyrightconfig.json                                [scaffolded]
├── Dockerfile                                        [scaffolded]
├── config.yaml                                       [scaffolded]
├── uv.lock                                           [generated by `just init`]
│
├── src/{service_name}/
│   ├── __init__.py                                   [create] package docstring + __version__
│   ├── app.py                                        [create] FastAPI app factory
│   ├── config.py                                     [create] Pydantic settings models + loader
│   ├── logging.py                                    [create] service-specific logging wrapper
│   ├── schemas.py                                    [create] Pydantic request/response models
│   │
│   ├── routers/
│   │   ├── __init__.py                               [create] re-export all router modules
│   │   ├── health.py                                 [create] GET /health endpoint
│   │   └── {domain}.py                               [create] service-specific API endpoints
│   │
│   ├── core/
│   │   ├── __init__.py                               [create] re-export AppState, ServiceError, etc.
│   │   ├── state.py                                  [create] AppState dataclass + global singleton
│   │   ├── lifespan.py                               [create] FastAPI lifespan context manager
│   │   └── exceptions.py                             [create] exception handlers wired to service-commons
│   │
│   └── services/
│       ├── __init__.py                               [create] re-export business logic classes
│       └── {domain}.py                               [create] business logic layer
│
└── tests/
    ├── __init__.py                                   [scaffolded]
    ├── conftest.py                                   [create] shared test config
    │
    ├── unit/
    │   ├── __init__.py                               [scaffolded]
    │   ├── conftest.py                               [create] unit test fixtures (settings cache clear)
    │   ├── test_config.py                            [create] config loading tests
    │   ├── test_{domain}.py                          [create] business logic unit tests
    │   └── routers/
    │       ├── __init__.py                           [create]
    │       ├── conftest.py                           [create] router test fixtures (mocked deps)
    │       ├── test_health.py                        [create] health endpoint unit tests
    │       └── test_{domain}.py                      [create] domain endpoint unit tests
    │
    ├── integration/
    │   ├── __init__.py                               [scaffolded]
    │   ├── conftest.py                               [create] integration fixtures (real app, real deps)
    │   └── test_endpoints.py                         [create] full endpoint integration tests
    │
    └── performance/
        ├── __init__.py                               [scaffolded]
        ├── conftest.py                               [create] performance test config
        └── test_performance.py                       [create] latency/throughput benchmarks
```

### Naming Conventions

The directory name uses kebab-case, the Python package uses snake_case:

| Service | Directory | Python Package |
|---|---|---|
| Identity & PKI | `services/identity` | `identity_service` |
| Central Bank | `services/central-bank` | `central_bank_service` |
| Task Board | `services/task-board` | `task_board_service` |
| Reputation | `services/reputation` | `reputation_service` |
| Civil Claims Court | `services/court` | `court_service` |

---

## File-by-File Implementation Reference

Each section below describes one file, its purpose, and shows the exact pattern to follow. Replace `{service_name}` with the actual package name (e.g., `identity_service`).

### src/{service_name}/__init__.py

Package marker with version string.

```python
"""
{Service Display Name} — one-line description.
"""

__version__ = "0.1.0"
```

### src/{service_name}/app.py

The FastAPI application factory. This is the entry point that uvicorn calls.

```python
"""
FastAPI application factory.
"""

from __future__ import annotations

from fastapi import FastAPI

from {service_name}.config import get_settings
from {service_name}.core.exceptions import register_exception_handlers
from {service_name}.core.lifespan import lifespan
from {service_name}.routers import health, {domain}


def create_app() -> FastAPI:
    """
    Create and configure FastAPI application.

    Returns:
        Configured FastAPI instance with all routers registered
    """
    settings = get_settings()

    app = FastAPI(
        title=f"{settings.service.name} Service",
        version=settings.service.version,
        lifespan=lifespan,
    )

    register_exception_handlers(app)

    app.include_router(health.router, tags=["Operations"])
    app.include_router({domain}.router, tags=["{Domain}"])

    return app
```

Key points:
- The function is named `create_app` (factory pattern). Uvicorn calls it with `--factory`.
- Settings are loaded first. If config.yaml is invalid, the app fails immediately.
- Lifespan handles startup/shutdown logic.
- Exception handlers are registered from service-commons.
- Each router is included with a tag for OpenAPI grouping.

### src/{service_name}/config.py

Pydantic settings models that mirror `config.yaml`, plus the cached loader.

```python
"""
Configuration management for the {service} service.

Loads configuration from YAML with ZERO defaults.
Every value must be explicitly specified or startup fails.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

from pydantic import BaseModel, ConfigDict
from service_commons.config import (
    REDACTION_MARKER,
    create_settings_loader,
    get_safe_model_config,
)
from service_commons.config import (
    get_config_path as resolve_config_path,
)

if TYPE_CHECKING:
    from pathlib import Path


class ServiceConfig(BaseModel):
    """Service identity configuration."""
    model_config = ConfigDict(extra="forbid")
    name: str
    version: str


class ServerConfig(BaseModel):
    """HTTP server configuration."""
    model_config = ConfigDict(extra="forbid")
    host: str
    port: int
    log_level: str


class LoggingConfig(BaseModel):
    """Logging configuration."""
    model_config = ConfigDict(extra="forbid")
    level: str
    format: str


# Add service-specific config sections here, e.g.:
# class DatabaseConfig(BaseModel):
#     model_config = ConfigDict(extra="forbid")
#     url: str


class Settings(BaseModel):
    """
    Root configuration container.

    All fields are REQUIRED. No defaults exist.
    Missing fields cause immediate startup failure.
    """
    model_config = ConfigDict(extra="forbid")
    service: ServiceConfig
    server: ServerConfig
    logging: LoggingConfig
    # Add service-specific sections: database: DatabaseConfig


def get_config_path() -> Path:
    """Determine configuration file path."""
    return resolve_config_path(
        env_var_name="CONFIG_PATH",
        default_filename="config.yaml",
    )


get_settings, clear_settings_cache = create_settings_loader(Settings, get_config_path)  # nosemgrep


def get_safe_config() -> dict[str, Any]:
    """Get configuration with sensitive values redacted."""
    return get_safe_model_config(get_settings(), REDACTION_MARKER)
```

Key points:
- Every Pydantic model uses `ConfigDict(extra="forbid")` — typos in config.yaml are caught immediately.
- No default values anywhere. If a field is missing from config.yaml, startup fails.
- `create_settings_loader` returns a cached getter and a cache-clearing function (for tests).
- The `# nosemgrep` comment on the loader line suppresses the no-default-values rule (it's a factory return, not a default).
- When adding service-specific config sections: add a new Pydantic model, add it to `Settings`, and add the corresponding YAML block to `config.yaml`.

### src/{service_name}/logging.py

Thin wrapper around service-commons logging with lazy import to avoid circular dependencies.

```python
"""
Structured JSON logging.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

from service_commons.logging import (
    VALID_LOG_LEVELS,
    JSONFormatter,
    get_named_logger,
    setup_logging,
)

if TYPE_CHECKING:
    import logging

__all__ = [
    "VALID_LOG_LEVELS",
    "JSONFormatter",
    "get_logger",
    "setup_logging",
]


def get_logger(name: str) -> logging.Logger:
    """Get a logger instance."""
    from {service_name}.config import get_settings  # noqa: PLC0415

    settings = get_settings()
    return get_named_logger(settings.service.name, name)
```

Key point: The lazy import inside `get_logger` avoids import-time config evaluation, which would fail before lifespan runs.

### src/{service_name}/schemas.py

All Pydantic models for request bodies, response bodies, and path/query parameters.

```python
"""
Pydantic request/response models for the API.
"""

from __future__ import annotations

from typing import Any, Literal

from pydantic import BaseModel, ConfigDict


class HealthResponse(BaseModel):
    """Response model for GET /health."""
    status: Literal["ok"]
    uptime_seconds: float
    started_at: str
    # Add service-specific health fields, e.g.:
    # registered_agents: int


class ErrorResponse(BaseModel):
    """Standard error response model."""
    error: str
    message: str
    details: dict[str, Any]


# Add domain-specific request/response models here.
```

### src/{service_name}/core/__init__.py

Re-exports for convenience imports.

```python
"""Core infrastructure components."""

from {service_name}.core.exceptions import ServiceError
from {service_name}.core.state import AppState, get_app_state, init_app_state

__all__ = ["AppState", "ServiceError", "get_app_state", "init_app_state"]
```

### src/{service_name}/core/state.py

Global application state singleton. Holds runtime objects (DB connections, service clients, etc.) initialized during lifespan.

```python
"""
Application state management.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import UTC, datetime


@dataclass
class AppState:
    """Runtime application state."""
    start_time: datetime = field(default_factory=lambda: datetime.now(UTC))
    # Add service-specific state, e.g.:
    # db: Database | None = None

    @property
    def uptime_seconds(self) -> float:
        """Calculate uptime in seconds."""
        return (datetime.now(UTC) - self.start_time).total_seconds()

    @property
    def started_at(self) -> str:
        """ISO format start time."""
        return self.start_time.isoformat()


# Global application state instance
_app_state: AppState | None = None


def get_app_state() -> AppState:
    """Get the current application state."""
    if _app_state is None:
        raise RuntimeError("Application state not initialized")
    return _app_state


def init_app_state() -> AppState:
    """Initialize application state. Called during startup."""
    global _app_state  # noqa: PLW0603
    _app_state = AppState()
    return _app_state


def reset_app_state() -> None:
    """Reset application state. Used in testing."""
    global _app_state  # noqa: PLW0603
    _app_state = None
```

Key point: `AppState` holds references to resources created during lifespan (DB connections, external clients). Routers access them via `get_app_state()`. Tests use `reset_app_state()` for isolation.

### src/{service_name}/core/lifespan.py

Startup and shutdown logic. This is where you create DB connections, load models, etc.

```python
"""Application lifecycle management."""

from __future__ import annotations

from contextlib import asynccontextmanager
from typing import TYPE_CHECKING

from {service_name}.config import get_settings
from {service_name}.core.state import init_app_state
from {service_name}.logging import get_logger, setup_logging

if TYPE_CHECKING:
    from collections.abc import AsyncIterator
    from fastapi import FastAPI


@asynccontextmanager
async def lifespan(_app: FastAPI) -> AsyncIterator[None]:
    """Manage application lifecycle."""
    # === STARTUP ===
    settings = get_settings()

    setup_logging(settings.logging.level, settings.service.name)
    logger = get_logger(__name__)

    state = init_app_state()

    # Initialize service-specific resources here, e.g.:
    # state.db = Database(settings.database.url)

    logger.info(
        "Service starting",
        extra={
            "service": settings.service.name,
            "version": settings.service.version,
            "port": settings.server.port,
        },
    )

    yield  # Application runs here

    # === SHUTDOWN ===
    logger.info("Service shutting down", extra={"uptime_seconds": state.uptime_seconds})
    # Clean up resources here, e.g.:
    # state.db.close()
```

Key points:
- Logging must be set up first (before any `get_logger` calls from other modules).
- `init_app_state()` creates the global state singleton.
- Resources are created between startup and `yield`. They are cleaned up after `yield`.

### src/{service_name}/core/exceptions.py

Wires the ServiceError from service-commons into the FastAPI app.

```python
"""Custom exception handlers for consistent error responses."""

from __future__ import annotations

from typing import TYPE_CHECKING

from fastapi.responses import JSONResponse
from service_commons.exceptions import ServiceError
from service_commons.exceptions import (
    register_exception_handlers as register_common_exception_handlers,
)

from {service_name}.logging import get_logger

if TYPE_CHECKING:
    from fastapi import FastAPI, Request

__all__ = ["ServiceError", "register_exception_handlers"]


async def service_error_handler(request: Request, exc: ServiceError) -> JSONResponse:
    """Handle ServiceError exceptions."""
    logger = get_logger(__name__)
    logger.warning(
        "Service error",
        extra={
            "error_code": exc.error,
            "status_code": exc.status_code,
            "path": str(request.url.path),
        },
    )
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": exc.error, "message": exc.message, "details": exc.details},
    )


async def unhandled_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    """Handle unexpected exceptions."""
    logger = get_logger(__name__)
    logger.exception("Unhandled exception", extra={"path": str(request.url.path)})
    return JSONResponse(
        status_code=500,
        content={"error": "internal_error", "message": "An unexpected error occurred", "details": {}},
    )


def register_exception_handlers(app: FastAPI) -> None:
    """Register all exception handlers on the app."""
    register_common_exception_handlers(
        app, ServiceError, service_error_handler, unhandled_exception_handler,
    )
```

### src/{service_name}/routers/__init__.py

Re-exports router modules so `app.py` can import them cleanly.

```python
"""API routers."""

from {service_name}.routers import health, {domain}

__all__ = ["health", "{domain}"]
```

### src/{service_name}/routers/health.py

Standard health endpoint. Every service has one.

```python
"""Health check endpoint."""

from __future__ import annotations

from fastapi import APIRouter

from {service_name}.core.state import get_app_state
from {service_name}.schemas import HealthResponse

router = APIRouter()


@router.get("/health", response_model=HealthResponse)
async def health_check() -> HealthResponse:
    """Check service health."""
    state = get_app_state()
    return HealthResponse(
        status="ok",
        uptime_seconds=state.uptime_seconds,
        started_at=state.started_at,
        # Add service-specific fields here
    )
```

### src/{service_name}/routers/{domain}.py

Domain-specific endpoints. This is where the actual API lives.

```python
"""
{Domain} endpoints.
"""

from __future__ import annotations

from fastapi import APIRouter

from {service_name}.core.exceptions import ServiceError
from {service_name}.core.state import get_app_state
from {service_name}.schemas import SomeRequest, SomeResponse

router = APIRouter()


@router.post("/some-endpoint", response_model=SomeResponse, status_code=201)
async def some_endpoint(request: SomeRequest) -> SomeResponse:
    """Do something."""
    state = get_app_state()
    # Access service-specific state: state.db, state.store, etc.
    # Call business logic from services/ layer
    # Raise ServiceError for handled errors
    ...
```

Key pattern: Routers are thin. They parse requests, call the business logic layer in `services/`, and return responses. They raise `ServiceError` for expected error conditions (404, 409, 400).

### src/{service_name}/services/__init__.py

Re-exports business logic classes.

```python
"""Service layer components."""

from {service_name}.services.{domain} import SomeService

__all__ = ["SomeService"]
```

### src/{service_name}/services/{domain}.py

Business logic. No FastAPI imports here — this is pure Python.

```python
"""
{Domain} business logic.
"""

from __future__ import annotations


class SomeService:
    """Handles {domain} operations."""

    def __init__(self, ...):
        ...

    def do_something(self, ...) -> ...:
        ...
```

Key point: The services layer is independent of FastAPI. It can be tested without HTTP. Routers instantiate or access these via `AppState`.

---

## config.yaml

When adding service-specific config sections, extend both the YAML file and the Pydantic models in `config.py`:

```yaml
service:
  name: "{service-dir}"
  version: "0.1.0"

server:
  host: "0.0.0.0"
  port: {port}
  log_level: "info"

logging:
  level: "INFO"
  format: "json"

# Service-specific sections, e.g.:
# database:
#   url: "sqlite:///data/identity.db"
```

---

## pyproject.toml

When adding service-specific dependencies, add them to the `dependencies` list:

```toml
dependencies = [
    "fastapi>=0.115.0",
    "uvicorn>=0.34.0",
    "pydantic>=2.10.0",
    "service-commons",
    # Add here, e.g.:
    # "cryptography>=44.0.0",
]
```

Then run `just init` to regenerate `uv.lock`.

---

## Implementation Sequence

For each service, follow this order:

1. **Add dependencies** to `pyproject.toml` if needed, then `just init`
2. **Extend `config.yaml`** with service-specific sections
3. **`config.py`** — add Pydantic models for the new config sections
4. **`__init__.py`** — package docstring and version
5. **`logging.py`** — copy the template (only the import path changes)
6. **`schemas.py`** — define all request/response Pydantic models
7. **`core/state.py`** — add service-specific fields to `AppState`
8. **`core/exceptions.py`** — copy the template (only the import path changes)
9. **`core/__init__.py`** — re-export
10. **`services/{domain}.py`** — implement business logic
11. **`services/__init__.py`** — re-export
12. **`routers/health.py`** — implement health endpoint
13. **`routers/{domain}.py`** — implement API endpoints
14. **`routers/__init__.py`** — re-export
15. **`core/lifespan.py`** — wire up resource initialization
16. **`app.py`** — wire up routers and exception handlers
17. **Run `just run`** — verify the service starts
18. **Write tests** — unit tests first, then integration

---

## Test Patterns

### Unit Tests

Unit tests mock external dependencies and test business logic in isolation. Located in `tests/unit/`.

Fixtures in `tests/unit/conftest.py`:
```python
import pytest
from {service_name}.config import clear_settings_cache

@pytest.fixture(autouse=True)
def _clear_caches():
    """Clear settings cache between tests."""
    clear_settings_cache()
    yield
    clear_settings_cache()
```

Router unit tests use `httpx.AsyncClient` with the FastAPI test client and mock the `AppState`.

### Integration Tests

Integration tests run against a real app instance with real (but temporary) resources. Located in `tests/integration/`.

Fixtures in `tests/integration/conftest.py`:
```python
import pytest
from httpx import ASGITransport, AsyncClient
from {service_name}.app import create_app

@pytest.fixture
def app():
    return create_app()

@pytest.fixture
async def client(app):
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as c:
        yield c
```

### Test Markers

All tests must be marked:
```python
@pytest.mark.unit
def test_something(): ...

@pytest.mark.integration
async def test_endpoint(): ...

@pytest.mark.performance
def test_throughput(): ...
```
